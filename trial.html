<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pixel Physics Car</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Courier New', monospace;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    .screen {
      max-width: 950px;
      width: 100%;
      animation: fadeIn 0.3s ease-in;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .hidden { display: none !important; }
    
    h1 {
      font-size: 3em;
      text-align: center;
      margin-bottom: 30px;
      text-shadow: 4px 4px 0 rgba(0,0,0,0.3);
      letter-spacing: 4px;
    }
    
    h2 {
      font-size: 2em;
      text-align: center;
      margin-bottom: 20px;
      text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
    }
    
    .panel {
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    }
    
    .btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 1.1em;
      font-family: 'Courier New', monospace;
      border-radius: 8px;
      cursor: pointer;
      margin: 10px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      border: 2px solid rgba(255,255,255,0.3);
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
      background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .menuBtns {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .small {
      text-align: center;
      margin-top: 20px;
      opacity: 0.8;
      font-size: 0.9em;
    }
    
    #topBar {
      display: flex;
      justify-content: space-between;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    
    #surfaceLabel {
      font-size: 1.5em;
      font-weight: bold;
      padding: 15px 25px;
      background: rgba(255,255,255,0.15);
      border-radius: 8px;
      border: 2px solid rgba(255,255,255,0.3);
      text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
    }
    
    #physicsPanel {
      flex: 1;
      min-width: 200px;
      font-size: 0.95em;
      line-height: 1.6;
    }
    
    .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .smallBtn {
      background: rgba(255,255,255,0.2);
      color: white;
      border: 2px solid rgba(255,255,255,0.3);
      padding: 10px 15px;
      font-family: 'Courier New', monospace;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .smallBtn:hover {
      background: rgba(255,255,255,0.3);
      transform: scale(1.05);
    }
    
    .smallBtn:active {
      transform: scale(0.95);
    }
    
    #canvasWrap {
      text-align: center;
    }
    
    #gameCanvas {
      width: 100%;
      height: auto;
      border-radius: 8px;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    
    #progressWrap {
      margin-top: 15px;
      text-align: center;
    }
    
    #progressWrap label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
    }
    
    progress {
      width: 100%;
      height: 30px;
      border-radius: 15px;
      overflow: hidden;
      border: 2px solid rgba(255,255,255,0.3);
    }
    
    progress::-webkit-progress-bar {
      background: rgba(0,0,0,0.3);
      border-radius: 15px;
    }
    
    progress::-webkit-progress-value {
      background: linear-gradient(90deg, #4ade80, #22c55e);
      border-radius: 15px;
      transition: width 0.3s ease;
    }
    
    progress::-moz-progress-bar {
      background: linear-gradient(90deg, #4ade80, #22c55e);
      border-radius: 15px;
    }
    
    .row {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    
    #resultsPanel div {
      margin: 10px 0;
      font-size: 1.1em;
    }
    
    #resultsPanel span {
      font-weight: bold;
      color: #4ade80;
    }
    
    #resultsGraph {
      width: 100%;
      height: auto;
      margin: 20px 0;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
    }
    
    ul {
      margin-left: 30px;
      line-height: 1.8;
    }
    
    ul li {
      margin: 8px 0;
    }
    
    p {
      line-height: 1.8;
      margin: 12px 0;
    }
    
    strong {
      color: #4ade80;
    }
  </style>
</head>
<body>
  <!-- MAIN MENU -->
  <div id="menuScreen" class="screen">
    <h1>üöó PIXEL CAR SIM</h1>
    <div class="menuBtns">
      <button id="startBtn" class="btn">üéÆ Start Simulation</button>
      <button id="instrBtn" class="btn">üìñ View Instructions</button>
    </div>
    <div class="small">Pixel-style physics demo ‚Äî use Arrow Keys to control your car!</div>
  </div>

  <!-- INSTRUCTIONS -->
  <div id="instructionsScreen" class="screen hidden">
    <h2>üìñ Instructions</h2>
    <div class="panel">
      <p><strong>Goal:</strong> Drive along a 300 m track with 3 different surfaces!</p>
      <ul>
        <li><strong>üßä Ice</strong> ‚Äî Very low friction (Œº=0.1), slides easily!</li>
        <li><strong>üèñÔ∏è Sand</strong> ‚Äî High friction (Œº=0.8), slows you down!</li>
        <li><strong>ü™µ Wood</strong> ‚Äî Medium friction (Œº=0.4), balanced surface!</li>
      </ul>
      <p><strong>Controls:</strong></p>
      <ul>
        <li><strong>‚Üë Arrow Up</strong> = Accelerate (adds +5 m/s¬≤)</li>
        <li><strong>‚Üì Arrow Down</strong> = Brake (adds -8 m/s¬≤)</li>
        <li><strong>Space</strong> = Pause/Resume simulation</li>
        <li><strong>R</strong> = Restart from beginning</li>
      </ul>
      <p>Watch the physics panel to monitor your speed, position, acceleration, friction coefficient, and slope angle in real-time!</p>
    </div>
    <div class="row">
      <button id="backFromInstr" class="btn">‚Üê Back</button>
    </div>
  </div>

  <!-- SIMULATION -->
  <div id="simScreen" class="screen hidden">
    <div id="topBar">
      <div id="surfaceLabel">Surface: -</div>
      <div id="physicsPanel" class="panel">
        <strong>Speed:</strong> <span id="speedVal">0.00</span> m/s<br>
        <strong>Position:</strong> <span id="posVal">0.00</span> m<br>
        <strong>Accel:</strong> <span id="accVal">0.00</span> m/s¬≤<br>
        <strong>Œº (friction):</strong> <span id="muVal">0.00</span><br>
        <strong>Slope:</strong> <span id="slopeVal">0.0</span>¬∞
      </div>
      <div class="controls panel">
        <button id="accelBtn" class="smallBtn">‚ñ≤ Accel</button>
        <button id="brakeBtn" class="smallBtn">‚ñº Brake</button>
        <button id="pauseBtn" class="smallBtn">‚è∏ Pause</button>
        <button id="restartBtn" class="smallBtn">‚Üª Restart</button>
        <button id="toMenuBtn" class="smallBtn">üè† Menu</button>
      </div>
    </div>

    <div id="canvasWrap" class="panel">
      <canvas id="gameCanvas" width="900" height="240"></canvas>
      <div id="progressWrap">
        <label for="progressBar">Track Progress (300m)</label>
        <progress id="progressBar" value="0" max="300"></progress>
      </div>
    </div>
  </div>

  <!-- RESULTS -->
  <div id="resultsScreen" class="screen hidden">
    <h2>üèÅ Results</h2>
    <div class="panel" id="resultsPanel">
      <div>üéØ Final distance: <span id="finalDistance">0.00</span> m</div>
      <div>‚ö° Final speed: <span id="finalSpeed">0.00</span> m/s</div>
      <div>‚è±Ô∏è Time duration: <span id="totalTime">0.00</span> s</div>
      <div>üêå Most challenging surface: <span id="worstSurface">-</span></div>
    </div>
    <canvas id="resultsGraph" width="700" height="180"></canvas>
    <div class="row">
      <button id="backToMenu" class="btn">üè† Back to Menu</button>
      <button id="restartFromResults" class="btn">‚Üª Restart</button>
    </div>
  </div>

<script>
// === GAME STATE ===
const state = {
  screen: 'menu',
  paused: false,
  pos: 0,
  vel: 0,
  acc: 0,
  time: 0,
  trackLength: 300,
  history: [],
  surfaceStats: { ice: 0, sand: 0, wood: 0 }
};

const keys = { up: false, down: false };

// === SURFACES ===
const surfaces = [
  { name: 'ice', start: 0, end: 100, mu: 0.1, color: '#a5f3fc', emoji: 'üßä' },
  { name: 'sand', start: 100, end: 200, mu: 0.8, color: '#fde047', emoji: 'üèñÔ∏è' },
  { name: 'wood', start: 200, end: 300, mu: 0.4, color: '#d97706', emoji: 'ü™µ' }
];

const GRAVITY = 9.8;
const ENGINE_ACC = 5;
const BRAKE_ACC = -8;
const SLOPE = 0;

// === ELEMENTS ===
const screens = {
  menu: document.getElementById('menuScreen'),
  instr: document.getElementById('instructionsScreen'),
  sim: document.getElementById('simScreen'),
  results: document.getElementById('resultsScreen')
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const resultsCanvas = document.getElementById('resultsGraph');
const resultsCtx = resultsCanvas.getContext('2d');

// === SCREEN MANAGEMENT ===
function showScreen(name) {
  Object.keys(screens).forEach(k => screens[k].classList.add('hidden'));
  screens[name].classList.remove('hidden');
  state.screen = name;
}

// === MENU HANDLERS ===
document.getElementById('startBtn').onclick = () => {
  resetSimulation();
  showScreen('sim');
};
document.getElementById('instrBtn').onclick = () => showScreen('instr');
document.getElementById('backFromInstr').onclick = () => showScreen('menu');
document.getElementById('toMenuBtn').onclick = () => showScreen('menu');
document.getElementById('backToMenu').onclick = () => showScreen('menu');
document.getElementById('restartFromResults').onclick = () => {
  resetSimulation();
  showScreen('sim');
};

// === CONTROL HANDLERS ===
document.getElementById('accelBtn').onclick = () => keys.up = !keys.up;
document.getElementById('brakeBtn').onclick = () => keys.down = !keys.down;
document.getElementById('pauseBtn').onclick = togglePause;
document.getElementById('restartBtn').onclick = () => resetSimulation();

function togglePause() {
  state.paused = !state.paused;
  document.getElementById('pauseBtn').textContent = state.paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
}

// === KEYBOARD ===
window.addEventListener('keydown', e => {
  if (state.screen !== 'sim') return;
  if (e.key === 'ArrowUp') keys.up = true;
  if (e.key === 'ArrowDown') keys.down = true;
  if (e.key === ' ') { e.preventDefault(); togglePause(); }
  if (e.key === 'r' || e.key === 'R') resetSimulation();
});

window.addEventListener('keyup', e => {
  if (e.key === 'ArrowUp') keys.up = false;
  if (e.key === 'ArrowDown') keys.down = false;
});

// === SIMULATION RESET ===
function resetSimulation() {
  state.pos = 0;
  state.vel = 0;
  state.acc = 0;
  state.time = 0;
  state.paused = false;
  state.history = [];
  state.surfaceStats = { ice: 0, sand: 0, wood: 0 };
  keys.up = false;
  keys.down = false;
  document.getElementById('pauseBtn').textContent = '‚è∏ Pause';
  document.getElementById('progressBar').value = 0;
}

// === PHYSICS ===
function getCurrentSurface() {
  return surfaces.find(s => state.pos >= s.start && state.pos < s.end) || surfaces[surfaces.length - 1];
}

function updatePhysics(dt) {
  if (state.paused || state.pos >= state.trackLength) return;
  
  const surface = getCurrentSurface();
  const mu = surface.mu;
  
  // Track time on each surface
  state.surfaceStats[surface.name] += dt;
  
  // Calculate acceleration
  let acc = 0;
  if (keys.up) acc += ENGINE_ACC;
  if (keys.down) acc += BRAKE_ACC;
  
  // Friction force
  const frictionAcc = -mu * GRAVITY * Math.sign(state.vel);
  if (Math.abs(state.vel) > 0.01) {
    acc += frictionAcc;
  }
  
  // Gravity on slope
  acc += GRAVITY * Math.sin(SLOPE * Math.PI / 180);
  
  state.acc = acc;
  state.vel += acc * dt;
  
  // Prevent negative speed
  if (state.vel < 0) state.vel = 0;
  
  state.pos += state.vel * dt;
  state.time += dt;
  
  // Clamp position
  if (state.pos >= state.trackLength) {
    state.pos = state.trackLength;
    state.vel = 0;
    showResults();
  }
  
  // Record history
  if (state.history.length === 0 || state.time - state.history[state.history.length - 1].t > 0.1) {
    state.history.push({ t: state.time, pos: state.pos, vel: state.vel });
  }
  
  updateUI(surface, mu);
}

// === UI UPDATE ===
function updateUI(surface, mu) {
  document.getElementById('surfaceLabel').textContent = `${surface.emoji} ${surface.name.toUpperCase()}`;
  document.getElementById('speedVal').textContent = state.vel.toFixed(2);
  document.getElementById('posVal').textContent = state.pos.toFixed(2);
  document.getElementById('accVal').textContent = state.acc.toFixed(2);
  document.getElementById('muVal').textContent = mu.toFixed(2);
  document.getElementById('slopeVal').textContent = SLOPE.toFixed(1);
  document.getElementById('progressBar').value = state.pos;
}

// === RENDERING ===
function render() {
  ctx.fillStyle = '#1e293b';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw track surfaces
  const scale = canvas.width / state.trackLength;
  surfaces.forEach(s => {
    ctx.fillStyle = s.color;
    ctx.fillRect(s.start * scale, 0, (s.end - s.start) * scale, canvas.height);
    
    // Draw surface labels
    ctx.fillStyle = '#000';
    ctx.font = 'bold 14px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(s.emoji + ' ' + s.name.toUpperCase(), (s.start + s.end) / 2 * scale, 30);
  });
  
  // Draw road markings
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.setLineDash([10, 10]);
  ctx.beginPath();
  ctx.moveTo(0, canvas.height / 2);
  ctx.lineTo(canvas.width, canvas.height / 2);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Draw car
  const carX = (state.pos / state.trackLength) * canvas.width;
  const carY = canvas.height / 2;
  const carW = 40;
  const carH = 24;
  
  // Car body
  ctx.fillStyle = '#ef4444';
  ctx.fillRect(carX - carW/2, carY - carH/2, carW, carH);
  
  // Car windows
  ctx.fillStyle = '#3b82f6';
  ctx.fillRect(carX - carW/2 + 8, carY - carH/2 + 4, 12, 8);
  ctx.fillRect(carX - carW/2 + 24, carY - carH/2 + 4, 12, 8);
  
  // Wheels
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(carX - 12, carY + carH/2, 6, 0, Math.PI * 2);
  ctx.arc(carX + 12, carY + carH/2, 6, 0, Math.PI * 2);
  ctx.fill();
  
  // Speed indicator
  if (state.vel > 0) {
    for (let i = 0; i < 3; i++) {
      ctx.fillStyle = `rgba(255,255,255,${0.6 - i * 0.2})`;
      ctx.fillRect(carX - carW/2 - 15 - i * 8, carY - 5, 6, 2);
      ctx.fillRect(carX - carW/2 - 15 - i * 8, carY + 3, 6, 2);
    }
  }
  
  // Distance markers
  ctx.fillStyle = '#fff';
  ctx.font = '12px monospace';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 300; i += 50) {
    const x = (i / state.trackLength) * canvas.width;
    ctx.fillText(i + 'm', x, canvas.height - 10);
  }
}

// === RESULTS ===
function showResults() {
  document.getElementById('finalDistance').textContent = state.pos.toFixed(2);
  document.getElementById('finalSpeed').textContent = state.vel.toFixed(2);
  document.getElementById('totalTime').textContent = state.time.toFixed(2);
  
  // Find worst surface
  const worst = Object.entries(state.surfaceStats).reduce((a, b) => a[1] > b[1] ? a : b);
  document.getElementById('worstSurface').textContent = worst[0].toUpperCase() + ' (' + worst[1].toFixed(1) + 's)';
  
  drawGraph();
  showScreen('results');
}

function drawGraph() {
  const w = resultsCanvas.width;
  const h = resultsCanvas.height;
  
  resultsCtx.fillStyle = '#1e293b';
  resultsCtx.fillRect(0, 0, w, h);
  
  if (state.history.length < 2) return;
  
  const maxT = state.history[state.history.length - 1].t;
  const maxV = Math.max(...state.history.map(p => p.vel));
  
  // Draw grid
  resultsCtx.strokeStyle = '#374151';
  resultsCtx.lineWidth = 1;
  for (let i = 0; i <= 5; i++) {
    const y = h - (i / 5) * h;
    resultsCtx.beginPath();
    resultsCtx.moveTo(0, y);
    resultsCtx.lineTo(w, y);
    resultsCtx.stroke();
  }
  
  // Draw speed line
  resultsCtx.strokeStyle = '#4ade80';
  resultsCtx.lineWidth = 3;
  resultsCtx.beginPath();
  
  state.history.forEach((p, i) => {
    const x = (p.t / maxT) * w;
    const y = h - (p.vel / maxV) * h;
    if (i === 0) resultsCtx.moveTo(x, y);
    else resultsCtx.lineTo(x, y);
  });
  
  resultsCtx.stroke();
  
  // Labels
  resultsCtx.fillStyle = '#fff';
  resultsCtx.font = 'bold 14px monospace';
  resultsCtx.fillText('Speed vs Time', 10, 20);
  resultsCtx.font = '12px monospace';
  resultsCtx.fillText(`Max: ${maxV.toFixed(1)} m/s`, 10, 40);
  resultsCtx.fillText(`Time: ${maxT.toFixed(1)} s`, w - 100, 20);
}

// === GAME LOOP ===
let lastTime = 0;
function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
  lastTime = timestamp;
  
  if (state.screen === 'sim') {
    updatePhysics(dt);
    render();
  }
  
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>